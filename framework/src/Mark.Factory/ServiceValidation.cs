// <auto-generated/>
// Service validation utilities for dependency injection generator
#nullable enable

using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;

namespace Mark.Factory
{
    /// <summary>
    /// Validation utilities for service registration
    /// </summary>
    internal static class ServiceValidation
    {
        /// <summary>
        /// Validates a service info and reports diagnostics
        /// </summary>
        public static bool ValidateService(ServiceInfo serviceInfo, INamedTypeSymbol typeSymbol, 
            SourceProductionContext context, out List<Diagnostic> diagnostics)
        {
            diagnostics = new List<Diagnostic>();
            bool isValid = true;

            // Validate lifetime attributes
            if (!ValidateLifetimeAttributes(serviceInfo, typeSymbol, diagnostics))
                isValid = false;

            // Validate service type compatibility
            if (!ValidateServiceType(serviceInfo, typeSymbol, diagnostics))
                isValid = false;

            // Validate factory method if specified
            if (!ValidateFactoryMethod(serviceInfo, typeSymbol, diagnostics))
                isValid = false;

            // Validate constructors
            ValidateConstructors(serviceInfo, typeSymbol, diagnostics);

            // Validate keyed service constraints
            if (!ValidateKeyedService(serviceInfo, diagnostics))
                isValid = false;

            // Validate decorator constraints
            if (!ValidateDecorator(serviceInfo, typeSymbol, diagnostics))
                isValid = false;

            // Validate abstract types
            if (!ValidateAbstractType(serviceInfo, typeSymbol, diagnostics))
                isValid = false;

            // Report all diagnostics
            foreach (var diagnostic in diagnostics)
            {
                context.ReportDiagnostic(diagnostic);
            }

            return isValid;
        }

        private static bool ValidateLifetimeAttributes(ServiceInfo serviceInfo, INamedTypeSymbol typeSymbol, 
            List<Diagnostic> diagnostics)
        {
            var lifetimeAttrs = typeSymbol.GetAttributes()
                .Where(a => a.AttributeClass?.Name?.EndsWith("Attribute") == true &&
                           (a.AttributeClass.Name == "SingletonAttribute" ||
                            a.AttributeClass.Name == "ScopedAttribute" ||
                            a.AttributeClass.Name == "TransientAttribute") &&
                           a.AttributeClass.ContainingNamespace?.ToDisplayString() == "Mark.Core")
                .ToList();

            if (lifetimeAttrs.Count == 0)
            {
                diagnostics.Add(Diagnostic.Create(
                    DiagnosticDescriptors.MissingLifetimeAttribute,
                    typeSymbol.Locations.FirstOrDefault(),
                    typeSymbol.Name));
                return false;
            }

            if (lifetimeAttrs.Count > 1)
            {
                diagnostics.Add(Diagnostic.Create(
                    DiagnosticDescriptors.MultipleLifetimeAttributes,
                    typeSymbol.Locations.FirstOrDefault(),
                    typeSymbol.Name));
                return false;
            }

            return true;
        }

        private static bool ValidateServiceType(ServiceInfo serviceInfo, INamedTypeSymbol typeSymbol, 
            List<Diagnostic> diagnostics)
        {
            if (serviceInfo.ServiceType != null)
            {
                // Simplified service type validation without compilation access
                
                // This is a simplified check - in a real implementation you'd want to resolve the type properly
                var serviceTypeName = serviceInfo.ServiceType.Split('.').Last().Replace(">", "").Replace("<", "");
                
                // Check if the implementation type implements or extends the service type
                bool isAssignable = false;
                
                // Check interfaces
                foreach (var iface in typeSymbol.AllInterfaces)
                {
                    if (iface.Name == serviceTypeName || iface.ToDisplayString() == serviceInfo.ServiceType)
                    {
                        isAssignable = true;
                        break;
                    }
                }
                
                // Check base types
                var baseType = typeSymbol.BaseType;
                while (baseType != null && !isAssignable)
                {
                    if (baseType.Name == serviceTypeName || baseType.ToDisplayString() == serviceInfo.ServiceType)
                    {
                        isAssignable = true;
                        break;
                    }
                    baseType = baseType.BaseType;
                }

                // Check if it's the same type
                if (typeSymbol.Name == serviceTypeName || typeSymbol.ToDisplayString() == serviceInfo.ServiceType)
                {
                    isAssignable = true;
                }

                if (!isAssignable)
                {
                    diagnostics.Add(Diagnostic.Create(
                        DiagnosticDescriptors.InvalidServiceType,
                        typeSymbol.Locations.FirstOrDefault(),
                        serviceInfo.ServiceType,
                        typeSymbol.ToDisplayString()));
                    return false;
                }
            }

            return true;
        }

        private static bool ValidateFactoryMethod(ServiceInfo serviceInfo, INamedTypeSymbol typeSymbol, 
            List<Diagnostic> diagnostics)
        {
            if (!serviceInfo.IsFactory || string.IsNullOrEmpty(serviceInfo.FactoryMethod))
                return true;

            var factoryMethod = typeSymbol.GetMembers(serviceInfo.FactoryMethod)
                .OfType<IMethodSymbol>()
                .FirstOrDefault(m => m.IsStatic && m.DeclaredAccessibility == Accessibility.Public);

            if (factoryMethod == null)
            {
                diagnostics.Add(Diagnostic.Create(
                    DiagnosticDescriptors.InvalidFactoryMethod,
                    typeSymbol.Locations.FirstOrDefault(),
                    serviceInfo.FactoryMethod,
                    typeSymbol.Name));
                return false;
            }

            // Validate factory method signature
            var returnType = factoryMethod.ReturnType;
            var expectedReturnType = serviceInfo.ServiceType ?? serviceInfo.ImplementationType;
            
            if (returnType.ToDisplayString() != expectedReturnType)
            {
                diagnostics.Add(Diagnostic.Create(
                    DiagnosticDescriptors.InvalidFactoryMethod,
                    factoryMethod.Locations.FirstOrDefault(),
                    serviceInfo.FactoryMethod,
                    typeSymbol.Name));
                return false;
            }

            return true;
        }

        private static void ValidateConstructors(ServiceInfo serviceInfo, INamedTypeSymbol typeSymbol, 
            List<Diagnostic> diagnostics)
        {
            if (serviceInfo.IsFactory || typeSymbol.IsAbstract || typeSymbol.TypeKind == TypeKind.Interface)
                return;

            var publicConstructors = typeSymbol.Constructors
                .Where(c => c.DeclaredAccessibility == Accessibility.Public)
                .ToList();

            if (!publicConstructors.Any())
            {
                diagnostics.Add(Diagnostic.Create(
                    DiagnosticDescriptors.NoPublicConstructor,
                    typeSymbol.Locations.FirstOrDefault(),
                    typeSymbol.Name));
            }
        }

        private static bool ValidateKeyedService(ServiceInfo serviceInfo, List<Diagnostic> diagnostics)
        {
            if (!serviceInfo.IsKeyed || serviceInfo.Key == null)
                return true;

            var keyType = serviceInfo.Key.GetType();
            
            if (keyType != typeof(string) && keyType != typeof(int) && keyType != typeof(long) && !keyType.IsEnum)
            {
                diagnostics.Add(Diagnostic.Create(
                    DiagnosticDescriptors.InvalidKeyType,
                    Location.None,
                    keyType.Name));
                return false;
            }

            return true;
        }

        private static bool ValidateDecorator(ServiceInfo serviceInfo, INamedTypeSymbol typeSymbol, 
            List<Diagnostic> diagnostics)
        {
            if (!serviceInfo.IsDecorator)
                return true;

            // Validate decorator pattern implementation
            foreach (var decorator in serviceInfo.Decorators)
            {
                // Check if the decorator implements the service interface
                var serviceTypeName = decorator.ServiceType.Split('.').Last();
                var implementsService = typeSymbol.AllInterfaces
                    .Any(i => i.Name == serviceTypeName || i.ToDisplayString() == decorator.ServiceType);

                if (!implementsService)
                {
                    diagnostics.Add(Diagnostic.Create(
                        DiagnosticDescriptors.InvalidServiceType,
                        typeSymbol.Locations.FirstOrDefault(),
                        decorator.ServiceType,
                        typeSymbol.ToDisplayString()));
                    return false;
                }

                // Check for constructor that accepts the service type (decorator pattern)
                var hasDecoratorConstructor = typeSymbol.Constructors.Any(c =>
                    c.Parameters.Any(p => p.Type.ToDisplayString() == decorator.ServiceType));

                if (!hasDecoratorConstructor)
                {
                    diagnostics.Add(Diagnostic.Create(
                        DiagnosticDescriptors.InvalidServiceType,
                        typeSymbol.Locations.FirstOrDefault(),
                        decorator.ServiceType,
                        typeSymbol.ToDisplayString()));
                    return false;
                }
            }

            return true;
        }

        private static bool ValidateAbstractType(ServiceInfo serviceInfo, INamedTypeSymbol typeSymbol, 
            List<Diagnostic> diagnostics)
        {
            if ((typeSymbol.IsAbstract || typeSymbol.TypeKind == TypeKind.Interface) && !serviceInfo.IsFactory)
            {
                diagnostics.Add(Diagnostic.Create(
                    DiagnosticDescriptors.AbstractTypeWithoutFactory,
                    typeSymbol.Locations.FirstOrDefault(),
                    typeSymbol.Name));
                return false;
            }

            return true;
        }

        /// <summary>
        /// Validates service registrations for conflicts
        /// </summary>
        public static void ValidateServiceConflicts(List<ServiceInfo> services, SourceProductionContext context)
        {
            var serviceTypeGroups = services
                .Where(s => s.ServiceType != null)
                .GroupBy(s => s.ServiceType)
                .Where(g => g.Count() > 1);

            foreach (var group in serviceTypeGroups)
            {
                var nonReplacing = group.Where(s => !s.ReplaceExisting).ToList();
                if (nonReplacing.Count > 1)
                {
                    context.ReportDiagnostic(Diagnostic.Create(
                        DiagnosticDescriptors.ConflictingRegistrations,
                        Location.None,
                        group.Key));
                }
            }
        }

        /// <summary>
        /// Reports informational diagnostics about service registrations
        /// </summary>
        public static void ReportServiceInfo(ServiceInfo serviceInfo, SourceProductionContext context)
        {
            // Report service registration info
            context.ReportDiagnostic(Diagnostic.Create(
                DiagnosticDescriptors.ServiceRegistered,
                Location.None,
                serviceInfo.ImplementationType,
                serviceInfo.ServiceType ?? "self",
                serviceInfo.Lifetime.ToString()));

            // Report auto-detected interfaces
            if (serviceInfo.ServiceType != null && !serviceInfo.AllAttributes
                .Any(a => a.AttributeClass?.Name == "RegisterServiceAttribute" && 
                         a.AttributeClass.ContainingNamespace?.ToDisplayString() == "Mark.Core"))
            {
                context.ReportDiagnostic(Diagnostic.Create(
                    DiagnosticDescriptors.AutoInterfaceDetected,
                    Location.None,
                    serviceInfo.ServiceType,
                    serviceInfo.ImplementationType));
            }

            // Report conditional registrations
            if (serviceInfo.IsConditional)
            {
                context.ReportDiagnostic(Diagnostic.Create(
                    DiagnosticDescriptors.ConditionalRegistration,
                    Location.None,
                    serviceInfo.ImplementationType,
                    serviceInfo.Condition ?? "unknown"));
            }
        }
    }
}