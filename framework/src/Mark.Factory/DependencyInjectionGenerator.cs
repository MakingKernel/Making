using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Mark.Factory;

/// <summary>
/// 依赖注入注册源生成器。
/// </summary>
[Generator]
public sealed class DependencyInjectionGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
#if DEBUG
        // 调试时可启用以下行以便附加调试器
        // if (!System.Diagnostics.Debugger.IsAttached) System.Diagnostics.Debugger.Launch();
#endif
        // 注册语法接收器，用于收集带有特性的类声明
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not SyntaxReceiver receiver || receiver.CandidateClasses.Count == 0)
        {
            return;
        }

        // 获取特性类型符号
        INamedTypeSymbol? singletonAttr = context.Compilation.GetTypeByMetadataName("Mark.SingletonAttribute");
        INamedTypeSymbol? scopedAttr = context.Compilation.GetTypeByMetadataName("Mark.ScopedAttribute");
        INamedTypeSymbol? transientAttr = context.Compilation.GetTypeByMetadataName("Mark.TransientAttribute");

        if (singletonAttr is null && scopedAttr is null && transientAttr is null)
        {
            return; // 未找到特性定义，提前退出
        }

        var registrations = new List<(string Lifetime, string ImplementationType)>();
        var seen = new HashSet<string>();

        // 1. 处理当前项目中的候选类（通过 SyntaxReceiver 收集，性能最优）
        foreach (var classDecl in receiver.CandidateClasses)
        {
            var model = context.Compilation.GetSemanticModel(classDecl.SyntaxTree);
            if (model.GetDeclaredSymbol(classDecl) is not INamedTypeSymbol typeSymbol)
                continue;

            TryAdd(typeSymbol);
        }

        // 2. 处理所有引用的程序集（包括自身 Assembly），以支持扫描其他项目/库中的类型
        foreach (var assembly in context.Compilation.SourceModule.ReferencedAssemblySymbols)
        {
            TraverseNamespace(assembly.GlobalNamespace);
        }

        // 也扫描当前 Assembly 内未被 SyntaxReceiver 捕获（例如通过反射动态生成的代码）
        TraverseNamespace(context.Compilation.Assembly.GlobalNamespace);

        if (registrations.Count == 0)
            return;

        GenerateSource(context, registrations);

        // 本地函数：尝试添加注册项
        void TryAdd(INamedTypeSymbol typeSymbol)
        {
            string? lifetime = GetLifetime(typeSymbol, singletonAttr, scopedAttr, transientAttr);
            if (lifetime is null)
                return;

            string implType = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            if (seen.Add(implType))
            {
                registrations.Add((lifetime, implType));
            }
        }

        // 本地函数：递归遍历命名空间中的所有类型
        void TraverseNamespace(INamespaceSymbol ns)
        {
            foreach (var member in ns.GetMembers())
            {
                if (member is INamespaceSymbol childNs)
                {
                    TraverseNamespace(childNs);
                }
                else if (member is INamedTypeSymbol type)
                {
                    TryAdd(type);
                }
            }
        }
    }

    private static string? GetLifetime(INamedTypeSymbol typeSymbol,
        INamedTypeSymbol? singletonAttr,
        INamedTypeSymbol? scopedAttr,
        INamedTypeSymbol? transientAttr)
    {
        foreach (var attr in typeSymbol.GetAttributes())
        {
            if (singletonAttr is not null && SymbolEqualityComparer.Default.Equals(attr.AttributeClass, singletonAttr))
                return "Singleton";
            if (scopedAttr is not null && SymbolEqualityComparer.Default.Equals(attr.AttributeClass, scopedAttr))
                return "Scoped";
            if (transientAttr is not null && SymbolEqualityComparer.Default.Equals(attr.AttributeClass, transientAttr))
                return "Transient";
        }

        return null;
    }

    private static void GenerateSource(GeneratorExecutionContext context,
        List<(string Lifetime, string ImplementationType)> regs)
    {
        var sb = new StringBuilder(@"// <auto-generated/>
using Microsoft.Extensions.DependencyInjection;

namespace Mark.Factory
{
    /// <summary>
    /// 由 DependencyInjectionGenerator 自动生成的服务注册扩展方法。
    /// </summary>
    public static class GeneratedServiceCollectionExtensions
    {
        /// <summary>
        /// 注册源码生成器扫描到的服务。
        /// </summary>
        public static IServiceCollection AddGeneratedServices(this IServiceCollection services)
        {
");

        foreach (var reg in regs)
        {
            sb.Append("            services.Add").Append(reg.Lifetime).Append('<').Append(reg.ImplementationType)
                .AppendLine(">();");
        }

        sb.Append(@"            return services;
        }
    }
}");

        context.AddSource("GeneratedServiceCollectionExtensions.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private sealed class SyntaxReceiver : ISyntaxReceiver
    {
        public List<ClassDeclarationSyntax> CandidateClasses { get; } = new();

        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
        {
            // 仅关注包含特性的类声明
            if (syntaxNode is ClassDeclarationSyntax classDecl && classDecl.AttributeLists.Count > 0)
            {
                CandidateClasses.Add(classDecl);
            }
        }
    }
}