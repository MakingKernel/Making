using System.Collections.Generic;
using System.Linq;
using System.Text;
using Mark.MiniApis.Analyzers.Models;

namespace Mark.MiniApis.Analyzers.Templates
{
    internal static class MainExtensionsTemplate
    {
        private const string Template = @"// <auto-generated />
// This code was generated by Mark MiniApi Source Generator
#nullable enable

using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.DependencyInjection;
using System.Linq;

namespace Microsoft.Extensions.DependencyInjection
{
    /// <summary>
    /// MiniApi extension methods for dependency injection and API mapping
    /// </summary>
    public static partial class MiniApiExtensions
    {
        /// <summary>
        /// Register all MiniApi classes with the specified service lifetime
        /// </summary>
        /// <param name=""services"">The service collection</param>
        /// <param name=""lifetime"">The service lifetime (default: Scoped)</param>
        /// <returns>The service collection for chaining</returns>
        public static IServiceCollection AddMiniApis(this IServiceCollection services, ServiceLifetime lifetime = ServiceLifetime.Scoped)
        {
{{DI_REGISTRATION}}
            return services;
        }

        /// <summary>
        /// Map all MiniApi endpoints to the web application
        /// </summary>
        /// <param name=""webApplication"">The web application</param>
        /// <returns>The web application for chaining</returns>
        public static WebApplication MapMiniApis(this WebApplication webApplication)
        {
{{MAP_METHODS}}
            return webApplication;
        }
    }
}";

        public static string Render(List<ClassInfo> classInfos)
        {
            var diRegistration = RenderDiRegistration(classInfos);
            var mapMethods = RenderMapMethods(classInfos);
            
            return Template
                .Replace("{{DI_REGISTRATION}}", diRegistration)
                .Replace("{{MAP_METHODS}}", mapMethods);
        }

        private static string RenderDiRegistration(List<ClassInfo> classInfos)
        {
            var sb = new StringBuilder();
            var classInfosByNamespace = classInfos
                .GroupBy(c => c.Namespace)
                .OrderBy(g => g.Key);
            
            sb.AppendLine("            switch (lifetime)");
            sb.AppendLine("            {");
            
            // Singleton
            sb.AppendLine("                case ServiceLifetime.Singleton:");
            RenderServiceRegistrations(sb, classInfosByNamespace, "AddSingleton");
            sb.AppendLine("                    break;");
            
            // Scoped
            sb.AppendLine("                case ServiceLifetime.Scoped:");
            RenderServiceRegistrations(sb, classInfosByNamespace, "AddScoped");
            sb.AppendLine("                    break;");
            
            // Transient
            sb.AppendLine("                case ServiceLifetime.Transient:");
            RenderServiceRegistrations(sb, classInfosByNamespace, "AddTransient");
            sb.AppendLine("                    break;");
            
            sb.AppendLine("            }");
            
            return sb.ToString();
        }

        private static void RenderServiceRegistrations(StringBuilder sb, IEnumerable<IGrouping<string, ClassInfo>> classInfosByNamespace, string method)
        {
            foreach (var group in classInfosByNamespace)
            {
                if (!string.IsNullOrEmpty(group.Key))
                {
                    sb.AppendLine($"                    // {group.Key}");
                }
                
                foreach (var classInfo in group.OrderBy(c => c.ClassName))
                {
                    var fullTypeName = string.IsNullOrEmpty(classInfo.Namespace) 
                        ? classInfo.ClassName 
                        : $"{classInfo.Namespace}.{classInfo.ClassName}";
                    sb.AppendLine($"                    services.{method}<{fullTypeName}>();");
                }
            }
        }

        private static string RenderMapMethods(List<ClassInfo> classInfos)
        {
            var sb = new StringBuilder();
            foreach (var classInfo in classInfos.OrderBy(c => c.Namespace).ThenBy(c => c.ClassName))
            {
                var methodName = Services.NamingService.GenerateMapMethodName(classInfo.ClassName);
                sb.AppendLine($"            webApplication.Map{methodName}();");
            }
            return sb.ToString();
        }
    }
}