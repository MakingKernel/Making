using System.Collections.Generic;
using System.Linq;
using System.Text;
using Mark.MiniApis.Analyzers.Models;

namespace Mark.MiniApis.Analyzers.Templates
{
    internal static class IndividualExtensionTemplate
    {
        private const string Template = @"// <auto-generated />
// This code was generated by Mark MiniApi Source Generator for {{CLASS_NAME}}
#nullable enable

using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.AspNetCore.Authorization;
using System.Linq;
{{NAMESPACE_IMPORTS}}

namespace Microsoft.Extensions.DependencyInjection
{
    /// <summary>
    /// MiniApi extension methods for {{CLASS_NAME}}
    /// </summary>
    public static partial class MiniApiExtensions
    {
        /// <summary>
        /// Map {{CLASS_NAME}} endpoints to the web application
        /// </summary>
        /// <param name="webApplication">The web application</param>
        /// <returns>The web application for chaining</returns>
        public static WebApplication Map{{METHOD_NAME}}(this WebApplication webApplication)
        {
            var {{INSTANCE_NAME}} = webApplication.MapGroup("{{ROUTE}}"){{CLASS_ATTRIBUTES}};

{{METHOD_MAPPINGS}}
            return webApplication;
        }
    }
}";

        public static string Render(ClassInfo classInfo)
        {
            var methodName = Services.NamingService.GenerateMapMethodName(classInfo.ClassName);
            var instanceName = Services.NamingService.GenerateInstanceName(classInfo.ClassName);
            var namespaceImports = RenderNamespaceImports(classInfo);
            var classAttributes = RenderClassAttributes(classInfo);
            var methodMappings = RenderMethodMappings(classInfo);
            
            return Template
                .Replace("{{CLASS_NAME}}", classInfo.ClassName)
                .Replace("{{METHOD_NAME}}", methodName)
                .Replace("{{INSTANCE_NAME}}", instanceName)
                .Replace("{{ROUTE}}", classInfo.Route)
                .Replace("{{NAMESPACE_IMPORTS}}", namespaceImports)
                .Replace("{{CLASS_ATTRIBUTES}}", classAttributes)
                .Replace("{{METHOD_MAPPINGS}}", methodMappings);
        }

        private static string RenderNamespaceImports(ClassInfo classInfo)
        {
            if (!string.IsNullOrEmpty(classInfo.Namespace))
            {
                return $"using {classInfo.Namespace};";
            }
            return string.Empty;
        }

        private static string RenderClassAttributes(ClassInfo classInfo)
        {
            var sb = new StringBuilder();

            // Add filter attributes
            foreach (var filterAttr in classInfo.FilterAttributes)
            {
                if (filterAttr.ConstructorArguments.Length > 0)
                {
                    var filterTypes = filterAttr.ConstructorArguments.FirstOrDefault().Values;
                    foreach (var filter in filterTypes)
                    {
                        if (filter.Value is Microsoft.CodeAnalysis.INamedTypeSymbol filterType)
                        {
                            sb.Append($".AddEndpointFilter<{filterType.ToDisplayString()}>()");
                        }
                    }
                }
            }
            
            // Add authorization
            if (classInfo.AuthorizeAttributes.Any())
            {
                var authorizationCode = RenderAuthorizationCode(classInfo.AuthorizeAttributes);
                if (!string.IsNullOrEmpty(authorizationCode))
                {
                    sb.Append(authorizationCode);
                }
            }

            // Add tags
            if (!string.IsNullOrEmpty(classInfo.Tags))
            {
                sb.Append($".WithTags("{classInfo.Tags}")");
            }

            return sb.ToString();
        }

        private static string RenderAuthorizationCode(List<Microsoft.CodeAnalysis.AttributeData> authorizeAttributes)
        {
            var rolesArg = authorizeAttributes
                .SelectMany(a => a.NamedArguments)
                .FirstOrDefault(n => n.Key == "Roles");
            
            var policyArg = authorizeAttributes
                .SelectMany(a => a.NamedArguments)
                .FirstOrDefault(n => n.Key == "Policy");

            if (!rolesArg.Equals(default) && !policyArg.Equals(default) && 
                rolesArg.Value.Value is string roles && policyArg.Value.Value is string policy)
            {
                return $".RequireAuthorization(p => p.RequireRole("{roles}").RequirePolicy("{policy}"))";
            }
            
            if (!rolesArg.Equals(default) && rolesArg.Value.Value is string role)
            {
                return $".RequireAuthorization(p => p.RequireRole("{role}"))";
            }
            
            if (!policyArg.Equals(default) && policyArg.Value.Value is string policyValue)
            {
                return $".RequireAuthorization("{policyValue}")";
            }
            
            return ".RequireAuthorization()";
        }

        private static string RenderMethodMappings(ClassInfo classInfo)
        {
            var sb = new StringBuilder();
            foreach (var method in classInfo.Methods.OrderBy(m => m.Name))
            {
                var mapping = MethodMappingTemplate.Render(method, classInfo);
                if (!string.IsNullOrWhiteSpace(mapping))
                    sb.AppendLine(mapping);
            }
            return sb.ToString();
        }
    }
}