using System.Collections.Generic;
using System.Text;

namespace Mark.MiniApis.Analyzers.Services
{
    internal static class TemplateService
    {
        public static string RenderMainExtensionsTemplate(List<Models.ClassInfo> classInfos)
        {
            var template = new StringBuilder();
            template.AppendLine("// <auto-generated />");
            template.AppendLine("// This code was generated by Mark MiniApi Source Generator");
            template.AppendLine("#nullable enable");
            template.AppendLine();
            template.AppendLine("using Microsoft.AspNetCore.Builder;");
            template.AppendLine("using Microsoft.Extensions.DependencyInjection;");
            template.AppendLine("using System.Linq;");
            template.AppendLine();
            template.AppendLine("namespace Microsoft.Extensions.DependencyInjection");
            template.AppendLine("{");
            template.AppendLine("    /// <summary>");
            template.AppendLine("    /// MiniApi extension methods for dependency injection and API mapping");
            template.AppendLine("    /// </summary>");
            template.AppendLine("    public static partial class MiniApiExtensions");
            template.AppendLine("    {");
            template.AppendLine("        /// <summary>");
            template.AppendLine("        /// Register all MiniApi classes with the specified service lifetime");
            template.AppendLine("        /// </summary>");
            template.AppendLine("        /// <param name="services">The service collection</param>");
            template.AppendLine("        /// <param name="lifetime">The service lifetime (default: Scoped)</param>");
            template.AppendLine("        /// <returns>The service collection for chaining</returns>");
            template.AppendLine("        public static IServiceCollection AddMiniApis(this IServiceCollection services, ServiceLifetime lifetime = ServiceLifetime.Scoped)");
            template.AppendLine("        {");
            template.AppendLine(RenderDiRegistration(classInfos));
            template.AppendLine("            return services;");
            template.AppendLine("        }");
            template.AppendLine();
            template.AppendLine("        /// <summary>");
            template.AppendLine("        /// Map all MiniApi endpoints to the web application");
            template.AppendLine("        /// </summary>");
            template.AppendLine("        /// <param name="webApplication">The web application</param>");
            template.AppendLine("        /// <returns>The web application for chaining</returns>");
            template.AppendLine("        public static WebApplication MapMiniApis(this WebApplication webApplication)");
            template.AppendLine("        {");
            
            foreach (var classInfo in classInfos.OrderBy(c => c.Namespace).ThenBy(c => c.ClassName))
            {
                var methodName = NamingService.GenerateMapMethodName(classInfo.ClassName);
                template.AppendLine($"            webApplication.Map{methodName}();");
            }
            
            template.AppendLine("            return webApplication;");
            template.AppendLine("        }");
            template.AppendLine("    }");
            template.AppendLine("}");

            return template.ToString();
        }

        private static string RenderDiRegistration(List<Models.ClassInfo> classInfos)
        {
            var sb = new StringBuilder();
            
            var classInfosByNamespace = classInfos
                .GroupBy(c => c.Namespace)
                .OrderBy(g => g.Key);
            
            sb.AppendLine("            switch (lifetime)");
            sb.AppendLine("            {");
            
            // Singleton
            sb.AppendLine("                case ServiceLifetime.Singleton:");
            foreach (var group in classInfosByNamespace)
            {
                if (!string.IsNullOrEmpty(group.Key))
                {
                    sb.AppendLine($"                    // {group.Key}");
                }
                
                foreach (var classInfo in group.OrderBy(c => c.ClassName))
                {
                    var fullTypeName = string.IsNullOrEmpty(classInfo.Namespace) 
                        ? classInfo.ClassName 
                        : $"{classInfo.Namespace}.{classInfo.ClassName}";
                    sb.AppendLine($"                    services.AddSingleton<{fullTypeName}>();");
                }
            }
            sb.AppendLine("                    break;");
            
            // Scoped
            sb.AppendLine("                case ServiceLifetime.Scoped:");
            foreach (var group in classInfosByNamespace)
            {
                if (!string.IsNullOrEmpty(group.Key))
                {
                    sb.AppendLine($"                    // {group.Key}");
                }
                
                foreach (var classInfo in group.OrderBy(c => c.ClassName))
                {
                    var fullTypeName = string.IsNullOrEmpty(classInfo.Namespace) 
                        ? classInfo.ClassName 
                        : $"{classInfo.Namespace}.{classInfo.ClassName}";
                    sb.AppendLine($"                    services.AddScoped<{fullTypeName}>();");
                }
            }
            sb.AppendLine("                    break;");
            
            // Transient
            sb.AppendLine("                case ServiceLifetime.Transient:");
            foreach (var group in classInfosByNamespace)
            {
                if (!string.IsNullOrEmpty(group.Key))
                {
                    sb.AppendLine($"                    // {group.Key}");
                }
                
                foreach (var classInfo in group.OrderBy(c => c.ClassName))
                {
                    var fullTypeName = string.IsNullOrEmpty(classInfo.Namespace) 
                        ? classInfo.ClassName 
                        : $"{classInfo.Namespace}.{classInfo.ClassName}";
                    sb.AppendLine($"                    services.AddTransient<{fullTypeName}>();");
                }
            }
            sb.AppendLine("                    break;");
            
            sb.AppendLine("            }");

            return sb.ToString();
        }
    }
}