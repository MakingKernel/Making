// <auto-generated/>
// Enhanced Dependency Injection Generator following MiniApiGenerator patterns
#nullable enable

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Mark.Factory
{
    /// <summary>
    /// Enhanced dependency injection registration source generator
    /// </summary>
    [Generator]
    public sealed class DependencyInjectionGenerator : IIncrementalGenerator
    {
        // Supported attribute names
        private static readonly HashSet<string> LifetimeAttributes = new()
        {
            "SingletonAttribute", "ScopedAttribute", "TransientAttribute"
        };

        private static readonly HashSet<string> AdvancedAttributes = new()
        {
            "FactoryAttribute", "KeyedAttribute", "DecoratorAttribute", "ConditionalAttribute",
            "OpenGenericAttribute", "MultipleAttribute", "HostedServiceAttribute", 
            "ConfigureAttribute", "RegisterServiceAttribute", "PriorityAttribute"
        };
        

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
#if DEBUG
            // Debug attachment for development
            // if (!System.Diagnostics.Debugger.IsAttached) System.Diagnostics.Debugger.Launch();
#endif

            // Create incremental data source for attributed classes
            var classDeclarations = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
                    transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
                .Where(static m => m is not null);

            // Get referenced classes from assemblies
            var compilationAndClasses = context.CompilationProvider.Combine(classDeclarations.Collect());

            // Register source output with duplicate prevention
            context.RegisterSourceOutput(compilationAndClasses, 
                static (spc, source) => Execute(source.Left, source.Right, spc));
        }

        private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
        {
            return node is ClassDeclarationSyntax classDecl && classDecl.AttributeLists.Count > 0;
        }

        private static ServiceInfo? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
        {
            var classDeclaration = (ClassDeclarationSyntax)context.Node;
            var symbol = context.SemanticModel.GetDeclaredSymbol(classDeclaration);
            
            if (symbol is not INamedTypeSymbol namedTypeSymbol)
                return null;

            return CreateServiceInfo(namedTypeSymbol);
        }

        private static void Execute(Compilation compilation, ImmutableArray<ServiceInfo?> classes, 
            SourceProductionContext context)
        {
            if (classes.Length == 0)
                return;

            // Get all attribute symbols
            var attributeSymbols = GetAttributeSymbols(compilation);
            if (!attributeSymbols.Any())
                return;

            var services = new List<ServiceInfo>();
            var seen = new HashSet<string>();
            var typeSymbols = new Dictionary<ServiceInfo, INamedTypeSymbol>();
            
            // Track already processed to prevent duplicate class generation
            var processedAssemblies = new HashSet<string>();

            // Process collected classes with validation
            foreach (var serviceInfo in classes)
            {
                if (serviceInfo is not null && TryAddService(serviceInfo, seen))
                {
                    // Find the type symbol for validation
                    var typeSymbol = FindTypeSymbol(serviceInfo.ImplementationType, compilation);
                    if (typeSymbol != null)
                    {
                        // Validate service and collect diagnostics
                        if (ServiceValidation.ValidateService(serviceInfo, typeSymbol, context, out var diagnostics))
                        {
                            services.Add(serviceInfo);
                            typeSymbols[serviceInfo] = typeSymbol;
                            
                            // Report informational diagnostics
                            ServiceValidation.ReportServiceInfo(serviceInfo, context);
                        }
                        // If validation fails, service is not added but diagnostics are already reported
                    }
                }
            }

            // Process referenced assemblies
            foreach (var assembly in compilation.SourceModule.ReferencedAssemblySymbols)
            {
                ProcessAssembly(assembly.GlobalNamespace, services, seen, attributeSymbols, compilation, context);
            }

            // Process current assembly
            ProcessAssembly(compilation.Assembly.GlobalNamespace, services, seen, attributeSymbols, compilation, context);

            if (!services.Any())
                return;

            // Remove duplicates based on implementation type and service type
            var uniqueServices = services
                .GroupBy(s => new { s.ImplementationType, s.ServiceType, s.Key })
                .Select(g => g.OrderBy(s => s.Priority).First())
                .ToList();

            // Validate service conflicts
            ServiceValidation.ValidateServiceConflicts(uniqueServices, context);

            // Sort services by priority
            uniqueServices.Sort((a, b) => a.Priority.CompareTo(b.Priority));

            // Generate source files
            string projectName = GetProjectName(compilation.AssemblyName);
            GenerateSource(context, uniqueServices, projectName);
        }

        private static Dictionary<string, INamedTypeSymbol> GetAttributeSymbols(Compilation compilation)
        {
            var symbols = new Dictionary<string, INamedTypeSymbol>();
            
            foreach (var attrName in LifetimeAttributes.Concat(AdvancedAttributes))
            {
                var symbol = compilation.GetTypeByMetadataName($"Mark.{attrName}");
                if (symbol is not null)
                {
                    symbols[attrName] = symbol;
                }
            }

            return symbols;
        }

        private static bool TryAddService(ServiceInfo serviceInfo, HashSet<string> seen)
        {
            string key = $"{serviceInfo.ImplementationType}:{serviceInfo.ServiceType}:{serviceInfo.Key}";
            return seen.Add(key);
        }

        private static void ProcessAssembly(INamespaceSymbol ns, List<ServiceInfo> services, 
            HashSet<string> seen, Dictionary<string, INamedTypeSymbol> attributeSymbols,
            Compilation compilation, SourceProductionContext context)
        {
            foreach (var member in ns.GetMembers())
            {
                if (member is INamespaceSymbol childNs)
                {
                    ProcessAssembly(childNs, services, seen, attributeSymbols, compilation, context);
                }
                else if (member is INamedTypeSymbol type)
                {
                    var serviceInfo = CreateServiceInfo(type);
                    if (serviceInfo is not null && TryAddService(serviceInfo, seen))
                    {
                        // Validate service and collect diagnostics
                        if (ServiceValidation.ValidateService(serviceInfo, type, context, out var diagnostics))
                        {
                            services.Add(serviceInfo);
                            
                            // Report informational diagnostics
                            ServiceValidation.ReportServiceInfo(serviceInfo, context);
                        }
                    }
                }
            }
        }

        private static INamedTypeSymbol? FindTypeSymbol(string fullTypeName, Compilation compilation)
        {
            // Remove global:: prefix if present
            var typeName = fullTypeName.StartsWith("global::") ? fullTypeName.Substring(8) : fullTypeName;
            
            // Try to get the type from the compilation
            var typeSymbol = compilation.GetTypeByMetadataName(typeName);
            if (typeSymbol != null)
                return typeSymbol;

            // If not found, search through all types in the compilation
            return FindTypeInNamespace(compilation.Assembly.GlobalNamespace, typeName) ??
                   compilation.SourceModule.ReferencedAssemblySymbols
                       .Select(assembly => FindTypeInNamespace(assembly.GlobalNamespace, typeName))
                       .FirstOrDefault(t => t != null);
        }

        private static INamedTypeSymbol? FindTypeInNamespace(INamespaceSymbol ns, string typeName)
        {
            foreach (var member in ns.GetMembers())
            {
                if (member is INamedTypeSymbol type && type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == typeName)
                {
                    return type;
                }
                else if (member is INamespaceSymbol childNs)
                {
                    var result = FindTypeInNamespace(childNs, typeName);
                    if (result != null)
                        return result;
                }
            }
            return null;
        }

        private static ServiceInfo? CreateServiceInfo(INamedTypeSymbol typeSymbol)
        {
            var attributes = typeSymbol.GetAttributes();
            if (!attributes.Any())
                return null;

            // Check for lifetime attributes
            var lifetime = GetServiceLifetime(typeSymbol, attributes);
            if (!lifetime.HasValue)
                return null;

            var serviceInfo = new ServiceInfo
            {
                Namespace = GetFullNamespace(typeSymbol.ContainingNamespace),
                ImplementationType = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                Lifetime = lifetime.Value,
                AllAttributes = attributes.ToList()
            };

            // Analyze all attributes
            AnalyzeAttributes(serviceInfo, typeSymbol, attributes);
            
            return serviceInfo;
        }

        private static ServiceLifetime? GetServiceLifetime(INamedTypeSymbol typeSymbol, 
            ImmutableArray<AttributeData> attributes)
        {
            foreach (var attr in attributes)
            {
                var attrName = attr.AttributeClass?.Name;
                var attrNamespace = attr.AttributeClass?.ContainingNamespace?.ToDisplayString();
                
                // Only check attributes from Mark namespace
                if (attrNamespace != "Mark")
                    continue;
                    
                switch (attrName)
                {
                    case "SingletonAttribute":
                        return ServiceLifetime.Singleton;
                    case "ScopedAttribute":
                        return ServiceLifetime.Scoped;
                    case "TransientAttribute":
                        return ServiceLifetime.Transient;
                }
            }

            return null;
        }

        private static void AnalyzeAttributes(ServiceInfo serviceInfo, INamedTypeSymbol typeSymbol, 
            ImmutableArray<AttributeData> attributes)
        {
            foreach (var attr in attributes)
            {
                var attrName = attr.AttributeClass?.Name;
                var attrNamespace = attr.AttributeClass?.ContainingNamespace?.ToDisplayString();
                
                // Only process attributes from Mark namespace
                if (attrNamespace != "Mark")
                    continue;
                
                switch (attrName)
                {
                    case "RegisterServiceAttribute":
                        AnalyzeRegisterServiceAttribute(serviceInfo, attr);
                        break;
                    case "FactoryAttribute":
                        AnalyzeFactoryAttribute(serviceInfo, attr);
                        break;
                    case "KeyedAttribute":
                        AnalyzeKeyedAttribute(serviceInfo, attr);
                        break;
                    case "DecoratorAttribute":
                        AnalyzeDecoratorAttribute(serviceInfo, attr);
                        break;
                    case "ConditionalAttribute":
                        AnalyzeConditionalAttribute(serviceInfo, attr);
                        break;
                    case "OpenGenericAttribute":
                        serviceInfo.IsOpenGeneric = true;
                        serviceInfo.RegistrationType = ServiceRegistrationType.OpenGeneric;
                        break;
                    case "MultipleAttribute":
                        AnalyzeMultipleAttribute(serviceInfo, attr);
                        break;
                    case "HostedServiceAttribute":
                        serviceInfo.IsHostedService = true;
                        serviceInfo.RegistrationType = ServiceRegistrationType.HostedService;
                        break;
                    case "ConfigureAttribute":
                        AnalyzeConfigureAttribute(serviceInfo, attr);
                        break;
                    case "PriorityAttribute":
                        AnalyzePriorityAttribute(serviceInfo, attr);
                        break;
                }
            }

            // Auto-detect service type if not explicitly set
            if (serviceInfo.ServiceType is null)
            {
                serviceInfo.ServiceType = GetAutoServiceType(typeSymbol);
            }
        }

        private static void AnalyzeRegisterServiceAttribute(ServiceInfo serviceInfo, AttributeData attr)
        {
            if (attr.ConstructorArguments.Length > 0)
            {
                var serviceTypeArg = attr.ConstructorArguments[0];
                if (serviceTypeArg.Value is INamedTypeSymbol serviceType)
                {
                    serviceInfo.ServiceType = serviceType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                }
            }
        }

        private static void AnalyzeFactoryAttribute(ServiceInfo serviceInfo, AttributeData attr)
        {
            serviceInfo.IsFactory = true;
            serviceInfo.RegistrationType = ServiceRegistrationType.Factory;
            
            if (attr.ConstructorArguments.Length > 0)
            {
                serviceInfo.FactoryMethod = attr.ConstructorArguments[0].Value?.ToString();
            }
        }

        private static void AnalyzeKeyedAttribute(ServiceInfo serviceInfo, AttributeData attr)
        {
            serviceInfo.IsKeyed = true;
            serviceInfo.RegistrationType = ServiceRegistrationType.Keyed;
            
            if (attr.ConstructorArguments.Length > 0)
            {
                var keyArg = attr.ConstructorArguments[0];
                serviceInfo.Key = keyArg.Value;
                serviceInfo.KeyType = keyArg.Type?.ToDisplayString();
            }
        }

        private static void AnalyzeDecoratorAttribute(ServiceInfo serviceInfo, AttributeData attr)
        {
            serviceInfo.IsDecorator = true;
            serviceInfo.RegistrationType = ServiceRegistrationType.Decorator;
            
            if (attr.ConstructorArguments.Length > 0)
            {
                var serviceTypeArg = attr.ConstructorArguments[0];
                if (serviceTypeArg.Value is INamedTypeSymbol serviceType)
                {
                    var decoratorInfo = new DecoratorInfo
                    {
                        ServiceType = serviceType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
                    };

                    // Check for Order property
                    var orderArg = attr.NamedArguments.FirstOrDefault(n => n.Key == "Order");
                    if (!orderArg.Equals(default) && orderArg.Value.Value is int order)
                    {
                        decoratorInfo.Order = order;
                    }

                    serviceInfo.Decorators.Add(decoratorInfo);
                }
            }
        }

        private static void AnalyzeConditionalAttribute(ServiceInfo serviceInfo, AttributeData attr)
        {
            serviceInfo.IsConditional = true;
            
            if (attr.ConstructorArguments.Length > 0)
            {
                serviceInfo.Condition = attr.ConstructorArguments[0].Value?.ToString();
            }
        }

        private static void AnalyzeMultipleAttribute(ServiceInfo serviceInfo, AttributeData attr)
        {
            serviceInfo.IsMultiple = true;
            serviceInfo.RegistrationType = ServiceRegistrationType.Multiple;
            
            var replaceArg = attr.NamedArguments.FirstOrDefault(n => n.Key == "ReplaceExisting");
            if (!replaceArg.Equals(default) && replaceArg.Value.Value is bool replace)
            {
                serviceInfo.ReplaceExisting = replace;
            }
        }

        private static void AnalyzeConfigureAttribute(ServiceInfo serviceInfo, AttributeData attr)
        {
            serviceInfo.HasConfiguration = true;
            
            if (attr.ConstructorArguments.Length > 0)
            {
                serviceInfo.ConfigurationKey = attr.ConstructorArguments[0].Value?.ToString();
            }
        }

        private static void AnalyzePriorityAttribute(ServiceInfo serviceInfo, AttributeData attr)
        {
            if (attr.ConstructorArguments.Length > 0 && attr.ConstructorArguments[0].Value is int priority)
            {
                serviceInfo.Priority = priority;
            }
        }

        private static string? GetAutoServiceType(INamedTypeSymbol typeSymbol)
        {
            string typeName = typeSymbol.Name;
            
            foreach (var interfaceType in typeSymbol.AllInterfaces)
            {
                string interfaceName = interfaceType.Name;
                
                if (interfaceName.StartsWith("I") && interfaceName.Length > 1)
                {
                    string expectedTypeName = interfaceName.Substring(1);
                    if (typeName == expectedTypeName)
                    {
                        return interfaceType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    }
                }
            }

            return null;
        }

        private static string GetFullNamespace(INamespaceSymbol? namespaceSymbol)
        {
            if (namespaceSymbol == null || namespaceSymbol.IsGlobalNamespace)
                return string.Empty;

            var parts = new List<string>();
            var current = namespaceSymbol;
            while (current is { IsGlobalNamespace: false })
            {
                parts.Insert(0, current.Name);
                current = current.ContainingNamespace;
            }

            return string.Join(".", parts);
        }

        private static void GenerateSource(SourceProductionContext context, List<ServiceInfo> services, string projectName)
        {
            string cleanProjectName = CleanProjectName(projectName);
            
            // Generate main extensions file with unique filename to prevent duplicates
            GenerateMainExtensionsFile(context, services, cleanProjectName);
            
            // Generate registration type specific files
            GenerateRegistrationTypeFiles(context, services, cleanProjectName);
        }

        private static void GenerateMainExtensionsFile(SourceProductionContext context, List<ServiceInfo> services, string projectName)
        {
            string className = $"Generated{projectName}ServiceExtensions";
            string methodName = $"Add{projectName}Services";
            string fileName = $"{className}.g.cs";

            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("// This code was generated by Mark.DependencyInjectionGenerator");
            sb.AppendLine("#nullable enable");
            sb.AppendLine();
            sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
            sb.AppendLine("using Microsoft.Extensions.Hosting;");
            sb.AppendLine("using Microsoft.Extensions.Configuration;");
            sb.AppendLine();
            sb.AppendLine("namespace Mark");
            sb.AppendLine("{");
            sb.AppendLine($"    /// <summary>");
            sb.AppendLine($"    /// Enhanced service registration extensions for {projectName}");
            sb.AppendLine($"    /// </summary>");
            sb.AppendLine($"    public static class {className}");
            sb.AppendLine("    {");
            sb.AppendLine($"        /// <summary>");
            sb.AppendLine($"        /// Register all {projectName} services with their configured lifetimes and options");
            sb.AppendLine($"        /// </summary>");
            sb.AppendLine($"        public static IServiceCollection {methodName}(this IServiceCollection services, IConfiguration? configuration = null)");
            sb.AppendLine("        {");

            // Group services by registration type
            var groupedServices = services.GroupBy(s => s.RegistrationType);

            foreach (var group in groupedServices.OrderBy(g => g.Key))
            {
                sb.AppendLine($"            // {group.Key} registrations");
                foreach (var service in group.OrderBy(s => s.Priority))
                {
                    var registration = GenerateServiceRegistration(service);
                    if (!string.IsNullOrEmpty(registration))
                    {
                        sb.AppendLine($"            {registration}");
                    }
                }
                sb.AppendLine();
            }

            sb.AppendLine("            return services;");
            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine("}");

            // Only generate if we have services to register
            if (services.Any())
            {
                context.AddSource(fileName, SourceText.From(sb.ToString(), Encoding.UTF8));
            }
        }

        private static string GenerateServiceRegistration(ServiceInfo service)
        {
            return service.RegistrationType switch
            {
                ServiceRegistrationType.Basic => GenerateBasicRegistration(service),
                ServiceRegistrationType.Factory => GenerateFactoryRegistration(service),
                ServiceRegistrationType.Keyed => GenerateKeyedRegistration(service),
                ServiceRegistrationType.Decorator => GenerateDecoratorRegistration(service),
                ServiceRegistrationType.OpenGeneric => GenerateOpenGenericRegistration(service),
                ServiceRegistrationType.HostedService => GenerateHostedServiceRegistration(service),
                ServiceRegistrationType.Multiple => GenerateMultipleRegistration(service),
                _ => GenerateBasicRegistration(service)
            };
        }

        private static string GenerateBasicRegistration(ServiceInfo service)
        {
            var lifetimeMethod = $"Add{service.Lifetime}";
            var registration = service.ServiceType != null
                ? $"services.{lifetimeMethod}<{service.ServiceType}, {service.ImplementationType}>();"
                : $"services.{lifetimeMethod}<{service.ImplementationType}>();";

            return WrapConditional(registration, service);
        }

        private static string GenerateFactoryRegistration(ServiceInfo service)
        {
            if (string.IsNullOrEmpty(service.FactoryMethod))
                return GenerateBasicRegistration(service);

            var lifetimeMethod = $"Add{service.Lifetime}";
            var factoryCall = $"{service.ImplementationType}.{service.FactoryMethod}";
            
            var registration = service.ServiceType != null
                ? $"services.{lifetimeMethod}<{service.ServiceType}>(provider => {factoryCall}(provider));"
                : $"services.{lifetimeMethod}(provider => {factoryCall}(provider));";

            return WrapConditional(registration, service);
        }

        private static string GenerateKeyedRegistration(ServiceInfo service)
        {
            if (service.Key == null) 
                return GenerateBasicRegistration(service);

            var lifetimeMethod = $"AddKeyed{service.Lifetime}";
            var keyValue = FormatKeyValue(service.Key, service.KeyType);
            
            var registration = service.ServiceType != null
                ? $"services.{lifetimeMethod}<{service.ServiceType}, {service.ImplementationType}>({keyValue});"
                : $"services.{lifetimeMethod}<{service.ImplementationType}>({keyValue});";

            return WrapConditional(registration, service);
        }

        private static string GenerateDecoratorRegistration(ServiceInfo service)
        {
            // This would typically use a decorator library like Scrutor
            var lifetimeMethod = $"Add{service.Lifetime}";
            var registration = $"services.{lifetimeMethod}<{service.ImplementationType}>();";
            
            return WrapConditional(registration, service);
        }

        private static string GenerateOpenGenericRegistration(ServiceInfo service)
        {
            var lifetimeMethod = $"Add{service.Lifetime}";
            var registration = service.ServiceType != null
                ? $"services.{lifetimeMethod}(typeof({service.ServiceType}), typeof({service.ImplementationType}));"
                : $"services.{lifetimeMethod}(typeof({service.ImplementationType}));";

            return WrapConditional(registration, service);
        }

        private static string GenerateHostedServiceRegistration(ServiceInfo service)
        {
            var registration = $"services.AddHostedService<{service.ImplementationType}>();";
            return WrapConditional(registration, service);
        }

        private static string GenerateMultipleRegistration(ServiceInfo service)
        {
            // Handle multiple implementations
            return GenerateBasicRegistration(service);
        }

        private static string WrapConditional(string registration, ServiceInfo service)
        {
            if (!service.IsConditional || string.IsNullOrEmpty(service.Condition))
                return registration;

            return service.Condition.ToLowerInvariant() switch
            {
                "development" => $"#if DEBUG\n            {registration}\n            #endif",
                "production" => $"#if !DEBUG\n            {registration}\n            #endif",
                _ => $"// Conditional: {service.Condition}\n            {registration}"
            };
        }

        private static string FormatKeyValue(object key, string? keyType)
        {
            return key switch
            {
                string s => $"\"{s}\"",
                int i => i.ToString(),
                long l => l.ToString(),
                _ => key.ToString() ?? "null"
            };
        }

        private static void GenerateRegistrationTypeFiles(SourceProductionContext context, List<ServiceInfo> services, string projectName)
        {
            // Generate specialized files for complex registration types if needed
            // This could include decorator chains, factory configurations, etc.
        }

        private static string CleanProjectName(string projectName)
        {
            if (string.IsNullOrEmpty(projectName))
                return "Unknown";

            var cleanName = projectName
                .Replace(".", "")
                .Replace("-", "")
                .Replace("_", "")
                .Replace(" ", "");

            if (cleanName.Length > 0 && !char.IsLetter(cleanName[0]))
            {
                cleanName = "Project" + cleanName;
            }

            return string.IsNullOrEmpty(cleanName) ? "Unknown" : cleanName;
        }

        private static string GetProjectName(string? assemblyName)
        {
            if (string.IsNullOrEmpty(assemblyName))
                return "Unknown";

            string projectName = assemblyName;

            string[] suffixesToRemove = { ".dll", ".exe" };
            foreach (var suffix in suffixesToRemove)
            {
                if (projectName.EndsWith(suffix, StringComparison.OrdinalIgnoreCase))
                {
                    projectName = projectName.Substring(0, projectName.Length - suffix.Length);
                }
            }

            var validChars = projectName.ToCharArray();
            for (int i = 0; i < validChars.Length; i++)
            {
                if (!char.IsLetterOrDigit(validChars[i]) && validChars[i] != '_')
                {
                    validChars[i] = '_';
                }
            }

            projectName = new string(validChars);

            if (projectName.Length > 0 && !char.IsLetter(projectName[0]) && projectName[0] != '_')
            {
                projectName = "_" + projectName;
            }

            return string.IsNullOrEmpty(projectName) ? "Unknown" : projectName;
        }
    }
}